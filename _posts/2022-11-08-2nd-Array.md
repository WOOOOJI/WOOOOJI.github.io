---
layout: post
title:  "JAVA 2차원 배열의 정의와 "
---

# 2차원 배열에 대해서 생각을 정리해봤다.



## 2차원 배열은 뭘까요오오?







(일단 배열이 먼지 복습 먼저 하고갑시다 !!!)









#### 배열(Array) : 동일한 자료형(Type)의 데이터를 연속된 공간에 저장하기 위한 **자료구조이다.**



#### 장점:

1. #### 연관된 데이터를 저장하기 위한 변수의 선언을 줄여준다.

2. #### 반복문과 같은 ~~문을(메소드...등등) 이용하여 계산과 같은 과정을 쉽게 처리할수 있다. 



#### 단점:

1. #### 배열의 길이는 가변형태가 아니다. 데이터값이 증가하면 배열의 크기를 재설정 해줘야 한다.

2. #### 배열안에는 같은 자료형만 올 수 있다. Ex) int,String 이 같이 담기는건 불가능 

   (추후에 Object을 다루게 되면 가능하다.)







---



### 그렇다면 2차원 배열은 뭐가 다를까?

 

#### 2차원 배열(Array) : 동일한 자료형(Type)의 데이터를 연속된 공간에 저장하기 위한 자료구조안에 동일한 자료구조가 들어가 있는것이다. 



생각보다 간단하죠?? ㅋ 실제로는 인덱싱 번호도 헷갈리고 아무튼 처음에는 이게 뭐야;; 이럴수도 있습니다 :)



---







#### 장점:

1. #### 연관된 데이터를 저장하기 위한 변수의 선언을 줄여준다.

2. #### 반복문과 같은 ~~문을(메소드...등등) 이용하여 계산과 같은 과정을 쉽게 처리할수 있다. 



#### 단점:

1. #### 배열의 길이는 가변형태가 아니다. 데이터값이 증가하면 배열의 크기를 재설정 해줘야 한다.

2. #### 배열안에는 같은 자료형만 올 수 있다. Ex) int,String 이 같이 담기는건 불가능 

   (추후에 Object을 다루게 되면 가능하다.)







---

### 문법 : 

1. 타입[ ] [ ] 배열이름;
2. 타입 배열이름[ ] [ ];
3. 타입[ ] 배열이름 [ ];   <= 이렇게 쓰는 사람 없죠?... 가능은 합니다 ^^







### 선언문:   2차원 배열의 선언은 1차원 배열과 같습니다. 아! 물론 괄호[] 가 하나 !  더 늘었어요 .....ㅠ

#### 1 : 선언과 동시에 데이터 저장.   **자료형[][] 변수 = {{데이터1}, {데이터2}, {데이터3}, {}, {} ... };**

```java
public static void main(String[] args) {
		// TODO Auto-generated method stub
			int[][] a = new int[][] { 
        											 { 1, 2, 3 },
                               { 4, 5, 6 }, 
                               { 7, 8, 9 } 
                              };               // 보기 편하시라고 ㅎ...
	    }
```



#### 2 : 선언시 배열의 크기를 지정하고 해당 인덱스에 데이터 저장. **자료형[][] 변수 = new 자료형[][];** 

```java
public static void main(String[] args) {
		// TODO Auto-generated method stub
			int[][] a = new int[][];
  	
  		a[0][0]=1;
  		a[0][1]=2;
  		a[0][2]=3;
  		a[1][0]=4;
  		a[1][1]=5;
  		a[1][2]=6;
  		......
  		a[n][i]=k;      
	    }
```





#### 장단점:

|                         1번의 장단점                         |
| :----------------------------------------------------------: |
|              **Good.**  일단 보기에 편하다 휴.               |
|      **Good.** 데이터들의 값을 알고 있을때는 유용하다.       |
| **Good.** 배열의 길이를 몰라도 **.length** 메소드 호출로 배열의 길이를 쉽게 알 수 있다. |
| **Bad.** 추후에 데이터가 증가하게 되면 배열의 크기를 그때마다 수정해줘야 한다 |



|                         2번의 장단점                         |
| :----------------------------------------------------------: |
| 솔직히 이렇게 쓰면 죽을때 까지 맞아야 합니다. VERY BAD :(  반복문 쓰세요 ㅡㅡ... |



## 정리 : 

1. 타입[ ] [ ] 배열이름;
2. 타입 배열이름[ ] [ ];
3. 타입[ ] [ ] 배열이름;   <= 이렇게 쓰는 사람 없죠?... 가능은 합니다 ^^



### 호출법 :  메소드 사용.  

위에서 만든 요일의 배열중 "목"에 해당되는 값을 얻으려면 다음과 같이 **인덱싱**을 이용해야 한다.

```java
String[][] weekend = {{"월", "화" },{ "수", "목"},{ "금", "토"},{"일","끝"}};
System.out.println(weekend[1][1]);
```

weekend[1] [1]  은 weekend 배열의 인덱싱 1번 배열안에 있는 배열의 1번 인덱싱이 "목" 이다.  (자바는 **0부터** 숫자를 센다.)





### 활용 예시 :  

```java
int[][] arr = new int[5][5];
		int count=1;
		for(int r=0; r<arr.length; r++) {
			System.out.println();
			for(int c=0; c<arr[r].length; c++) {
				arr[r][c] = count++;
				System.out.print(arr[r][c]+"\t");
			}
		}
  출력:1 2 3 4 5	

      6	7	8	9	10	

      11	12	13	14	15	

      16	17	18	19	20	

      21	22	23	24	25
```



1. 배열에 반복문을 이용하여 해당 인덱스값을 순차적으로 r, c값을 증가시킴에 따라 변경하게 하여 1씩 증가된 값을넣어줬다.
2. 배열의 크기를 넘어서면 줄바꿈을 해준다.













## 여전히 자주보는 배열의 오류

(특히나 2차원 배열하면 더욱 덬ㅋㅋㅋㅋㅋㅋㅋ)

자바 코드를 작성하면서 보게 될 가장 많은 오류중의 하나는 바로 **다음의 오류** 지요~

```no-highlight
ArrayIndexOutOfBoundsException
```

다음의 예처럼 요일 배열의 길이는 총 6개인데 만약 7번째 값을 얻으려고 시도하면 이와 같은 오류가 발생한다.

```java
System.out.println(weekend[2][2]);  // 8번째 배열값이 없으므로 ArrayIndexOutOfBoundsException 오류가 발생한다.
```

**자바는 0부터 숫자를 센다.** 익숙해 지겠지요 아마도....
